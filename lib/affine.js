// Generated by CoffeeScript 1.9.3
(function() {
  var affine2d, flipX, flipY, posRotScale, reflection, reflectionUnit, rotation, scaling, translation,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  exports.compose = function(a1, a2) {
    var res;
    res = a2.copy();
    res.rightComposeWith(a1);
    return res;
  };

  affine2d = (function() {
    function affine2d() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (args.length === 0) {
        this.m00 = 1;
        this.m01 = 0;
        this.m10 = 0;
        this.m11 = 1;
        this.v0 = 0;
        this.v1 = 0;
      } else if (args.length === 1) {
        this.m00 = args[0].m00;
        this.m01 = args[0].m01;
        this.m10 = args[0].m10;
        this.m11 = args[0].m11;
        this.v0 = args[0].v0;
        this.v1 = args[0].v1;
      } else {
        this.m00 = args[0];
        this.m01 = args[1];
        this.m10 = args[2];
        this.m11 = args[3];
        this.v0 = args[4];
        this.v1 = args[5];
      }
    }

    affine2d.prototype.oneLineSummary = function() {
      return ("M = [" + (this.m00.toPrecision(3))) + (" " + (this.m01.toPrecision(3))) + (" " + (this.m10.toPrecision(3))) + (" " + (this.m11.toPrecision(3)) + "]   V = (") + ((this.v0.toPrecision(3)) + ", ") + (" " + (this.v1.toPrecision(3)) + ")   scale = ") + this.getXCenter().toPrecision(3) + " x " + this.getYCenter().toPrecision(3);
    };

    affine2d.prototype.copy = function() {
      return new affine2d(this);
    };

    affine2d.prototype.setCtxTransform = function(ctx) {

      /*
      if you have an HTML5 canvas and want to **set**
      its transform to match this affine, use this
       */
      return ctx.setTransform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.applyToCtx = function(ctx) {

      /*
      if you have an HTML5 canvas and want to **apply**
      this transform to its existing one, use this
       */
      return ctx.transform(this.m00, this.m10, this.m01, this.m11, this.v0, this.v1);
    };

    affine2d.prototype.transformPair = function(v0, v1) {
      var t0, t1;
      t0 = this.m00 * v0 + this.m01 * v1 + this.v0;
      t1 = this.m10 * v0 + this.m11 * v1 + this.v1;
      return [t0, t1];
    };

    affine2d.prototype.transformVec = function(a) {
      var t0, t1;
      t0 = this.m00 * a[0] + this.m01 * a[1] + this.v0;
      t1 = this.m10 * a[0] + this.m11 * a[1] + this.v1;
      a[0] = t0;
      a[1] = t1;
      return a;
    };

    affine2d.prototype.rightComposeWith = function(a) {

      /*
      Typically when you have an affine A and you want to
      perform another affine on it, use this.
      In other words:
        A.rightComposeWith(B)
        performs the composition B(A) and replaces A with the results.
       */
      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = a.m00 * this.m10 + a.m10 * this.m11;
      t_m11 = a.m01 * this.m10 + a.m11 * this.m11;
      t_v1 = a.v0 * this.m10 + a.v1 * this.m11 + this.v1;
      t_m00 = a.m00 * this.m00 + a.m10 * this.m01;
      t_m01 = a.m01 * this.m00 + a.m11 * this.m01;
      t_v0 = a.v0 * this.m00 + a.v1 * this.m01 + this.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;
    };

    affine2d.prototype.leftComposeWith = function(a) {

      /*
      A.leftComposeWith(B)
      performs the composition A(B) and replaces A with the results
       */
      var t_m00, t_m01, t_m10, t_m11, t_v0, t_v1;
      t_m10 = this.m00 * a.m10 + this.m10 * a.m11;
      t_m11 = this.m01 * a.m10 + this.m11 * a.m11;
      t_v1 = this.v0 * a.m10 + this.v1 * a.m11 + a.v1;
      t_m00 = this.m00 * a.m00 + this.m10 * a.m01;
      t_m01 = this.m01 * a.m00 + this.m11 * a.m01;
      t_v0 = this.v0 * a.m00 + this.v1 * a.m01 + a.v0;
      this.m00 = t_m00;
      this.m01 = t_m01;
      this.m10 = t_m10;
      this.m11 = t_m11;
      this.v0 = t_v0;
      return this.v1 = t_v1;

      /*
        a = m00
        b = m10
        d = m01
        e = m11
       */
    };

    affine2d.prototype.deconstruct = function() {

      /*
      returns [xscale, yscale, yshearing, rotation, xtranslation, ytranslation]
      assuming they are applied in that order
       */
      var rotation, xscale, xtranslation, yscale, yshear, ytranslation;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      yscale = (this.m00 * this.m11 - this.m10 * this.m01) / xscale;
      yshear = (this.m00 * this.m01 + this.m10 * this.m11) / (this.m00 * this.m11 - this.m10 * this.m01);
      rotation = Math.atan2(this.m10, this.m00);
      xtranslation = this.v0;
      ytranslation = this.v1;
      return [xscale, yscale, yshear, rotation, xtranslation, ytranslation];
    };

    affine2d.prototype.toPosRotScale = function() {

      /*
      this only makes sense if you know your affine only consists
      of a position, rotation, and scaling (i.e., no shearing).
      
      a posRotScale consists of a:
        1. translation
        2. rotation
        3. scaling
      i.e.
        - no shearing
        - they're applied in the above order, which is a natural way of thinking of thinking of object placement
      Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
      by using super's toPosRotScale function
       */
      var xscale;
      xscale = Math.sqrt(this.m00 * this.m00 + this.m10 * this.m10);
      return {
        pos: [this.v0, this.v1],
        rot: Math.atan2(this.m10, this.m00),
        scale: [xscale, (this.m00 * this.m11 - this.m10 * this.m01) / xscale]
      };
    };

    affine2d.prototype.getXCenter = function() {
      return this.v0;
    };

    affine2d.prototype.getYCenter = function() {
      return this.v1;
    };

    affine2d.prototype.scale = function(scale1, scale2) {
      if (scale2 == null) {
        scale2 = scale1;
      }
      return this.rightComposeWith(new scaling(scale1, scale2));
    };

    affine2d.prototype.rotate = function(r) {
      return this.rightComposeWith(new rotation(r));
    };

    affine2d.prototype.translate = function(x, y) {
      return this.rightComposeWith(new translation(x, y));
    };

    affine2d.prototype.flipX = function() {
      return this.rightComposeWith(new flipX());
    };

    affine2d.prototype.flipY = function() {
      return this.rightComposeWith(new flipY());
    };

    affine2d.prototype.reflect = function(angle_or_unit_x, unit_y) {
      if (unit_y != null) {
        return this.rightComposeWith(new reflectionUnit(angle_or_unit_x, unit_y));
      } else {
        return this.rightComposeWith(new reflection(angle_or_unit_x));
      }
    };

    return affine2d;

  })();

  rotation = (function(superClass) {
    extend(rotation, superClass);

    function rotation(r) {
      rotation.__super__.constructor.call(this, Math.cos(r), -Math.sin(r), Math.sin(r), Math.cos(r), 0, 0);
    }

    return rotation;

  })(affine2d);

  scaling = (function(superClass) {
    extend(scaling, superClass);

    function scaling(sx, sy) {
      scaling.__super__.constructor.call(this, sx, 0, 0, sy, 0, 0);
    }

    return scaling;

  })(affine2d);

  translation = (function(superClass) {
    extend(translation, superClass);

    function translation(x, y) {
      translation.__super__.constructor.call(this, 1, 0, 0, 1, x, y);
    }

    return translation;

  })(affine2d);

  reflectionUnit = (function(superClass) {
    extend(reflectionUnit, superClass);

    function reflectionUnit(ux, uy) {
      reflectionUnit.__super__.constructor.call(this, 2.0 * ux * ux - 1.0, 2.0 * ux * uy, 2.0 * ux * uy, 2.0 * uy * uy - 1.0, 0.0, 0.0);
    }

    return reflectionUnit;

  })(affine2d);

  reflection = (function(superClass) {
    extend(reflection, superClass);

    function reflection(r) {
      reflection.__super__.constructor.call(this, Math.cos(r, Math.sin(r)));
    }

    return reflection;

  })(reflectionUnit);

  flipX = (function(superClass) {
    extend(flipX, superClass);

    function flipX() {
      flipX.__super__.constructor.call(this, -1, 0, 0, 1, 0, 0);
    }

    return flipX;

  })(affine2d);

  flipY = (function(superClass) {
    extend(flipY, superClass);

    function flipY() {
      flipY.__super__.constructor.call(this, 1, 0, 0, -1, 0, 0);
    }

    return flipY;

  })(affine2d);

  posRotScale = (function(superClass) {
    extend(posRotScale, superClass);


    /*
    a posRotScale consists of a:
      1. translation
      2. rotation
      3. scaling
    i.e.
      - no shearing
      - they're applied in the above order, which is a natural way of thinking of thinking of object placement
    Note that you can then extract the pos, rot, and scaling from a posRotScale (or modified one)
    by using super's toPosRotScale function
     */

    function posRotScale(arg) {
      var pos, rot, scale;
      pos = arg.pos, rot = arg.rot, scale = arg.scale;
      posRotScale.__super__.constructor.call(this);
      this.translate(pos[0], pos[1]);
      this.rotate(rot);
      if ((typeof scale) === "number") {
        this.scale(scale);
      } else if (scale.length === 1) {
        this.scale(scale[0]);
      } else {
        this.scale(scale[0], scale[1]);
      }
    }

    return posRotScale;

  })(affine2d);

  exports.affine2d = affine2d;

  exports.rotation = rotation;

  exports.scaling = scaling;

  exports.translation = translation;

  exports.reflectionUnit = reflectionUnit;

  exports.reflection = reflection;

  exports.flipX = flipX;

  exports.flipY = flipY;

  exports.posRotScale = posRotScale;

}).call(this);
