// Generated by CoffeeScript 1.9.3
(function() {
  var affine, polygon;

  affine = require('./affine');

  polygon = (function() {
    function polygon(vertices) {
      if (vertices != null) {
        this.vertices = vertices;
      } else {
        this.vertices = [];
      }
    }

    polygon.prototype.copy = function() {
      var j, len, new_v, ref, v;
      new_v = [];
      ref = this.vertices;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        new_v.push(v.copy());
      }
      return new polygon(new_v);
    };

    polygon.prototype.addVertex = function(v) {
      return this.vertices.push(v);
    };

    polygon.prototype.transform = function(aff) {
      var j, len, ref, results, v;
      ref = this.vertices;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        results.push(aff.transformVec(v));
      }
      return results;
    };

    polygon.prototype.getBoundingRectangle = function() {

      /*
      returns a pair of pairs; 
      for example: [[1,2],[3,5]] 
      means that  1 <= x <= 3
              and 2 <= y <= 5
      for all points
       */
      var i, j, len, ref, v, x;
      x = null;
      ref = this.vertices;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        v = ref[i];
        if (i === 0) {
          x = [[v[0], v[1]], [v[0], v[1]]];
        } else {
          if (v[0] < x[0][0]) {
            x[0][0] = v[0];
          }
          if (v[0] > x[1][0]) {
            x[1][0] = v[0];
          }
          if (v[1] < x[0][1]) {
            x[0][1] = v[1];
          }
          if (v[1] > x[1][1]) {
            x[1][1] = v[1];
          }
        }
      }
      return x;
    };

    return polygon;

  })();

  exports.polygon = polygon;

  exports.factory = {
    unitSquare: function() {
      return new polygon([[0.5, 0.5], [-0.5, 0.5], [-0.5, -0.5], [0.5, -0.5]]);
    },
    unitCircleApprox: function(num) {
      var i, j, p, radian_increment, radians, ref;
      radian_increment = 2.0 * Math.PI / num;
      radians = 0;
      p = new polygon();
      for (i = j = 0, ref = num; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        radians += radian_increment;
        p.addVertex([0.5 * Math.cos(radians), 0.5 * Math.sin(radians)]);
      }
      return p;
    }
  };

}).call(this);
